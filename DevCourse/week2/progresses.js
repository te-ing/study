/** whileì„ ì“°ì§€ ì•Šê³  progressê°€ 100ì´ ë˜ëŠ” ê¸°ê°„ì„ êµ¬í•˜ëŠ” ê²ƒ ê¹Œì§€ëŠ” êµ¬í˜„í–ˆì—ˆì§€ë§Œ,
forë¬¸ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³ ëŠ” ì•žì˜ ê°’ë³´ë‹¤ ìž‘ì€ ìˆ˜ì˜ ê°¯ìˆ˜ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤...ðŸ˜¥
ì•žë¶€ë¶„ì´ ì œ ì½”ë“œì™€ ì¼ì¹˜í•˜ëŠ” ê²ƒì„ ë³´ë©´ì„œ ì¡°ê¸ˆë§Œ ë” í•´ë³¼ê±¸ í•˜ëŠ” ì•„ì‰¬ì›€ì´ ë‚¨ë„¤ìš”.
incë¥¼ ê°¯ìˆ˜ ì„¸ëŠ” ê²ƒì—ë§Œ ì‚¬ìš©í•  ìˆ˜ ìžˆì„ê±°ë¼ ìƒê°í–ˆëŠ”ë°, countì™€ periodë¥¼ ì´ìš©í•˜ì—¬
ì¡°ê±´ë¬¸ì„ êµ¬í˜„í•˜ëŠ” ê²ƒì„ ë³´ê³ , í•¨ìˆ˜ë¥¼ ì—¬ëŸ¬ ë°©ë²•ìœ¼ë¡œ í™œìš©í•  í•„ìš”ë¥¼ ëŠê¼ˆìŠµë‹ˆë‹¤.

í•¨ìˆ˜í˜• ì‚¬ê³ ë¥¼ í†µí•´ ì•Œê³ ë¦¬ì¦˜ì„ ì§œë‹¤ ë³´ë‹ˆ,
ì–´ë–»ê²Œ í’€ì–´ë‚¼ ìˆ˜ ìžˆì„ê¹Œ ë³´ë‹¤ ì–´ë–»ê²Œ ê³„ì‚°í•´ì•¼ í• ê¹Œ ë¥¼ ë” ìƒê°í•´ë³´ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.
ì´ì „ì´ë¼ë©´ íš¨ìœ¨ì„±ì„ ìƒê°í•˜ì§€ ì•Šê³  ì‰½ê²Œ ë½‘ì•„ëƒˆì„ periodë„ ê³„ì‚°ì„ í†µí•´ ë½‘ì•„ë‚´ëŠ” ì œ ëª¨ìŠµì„ ë³´ê³ , 
ë§Žì´ ì–´ë ¤ì› ë˜ ê³µë¶€ì˜€ì§€ë§Œ ê·¸ëž˜ë„ ì¡°ê¸ˆì€ ë°°ì› êµ¬ë‚˜ ì‹¶ì€ ë§ˆìŒì´ ë“¤ì—ˆìŠµë‹ˆë‹¤.
*/

const featureCount = periods =>
    reduce(([counts, total_period], period) =>
        total_period < period
            ? [inc(counts, counts.length), period]
            : [inc(counts, counts.length-1), total_period])([[], 0], periods);

const solution = (progresses, speeds) => go(
    zip(progresses)(speeds),
    map(([progress, speed]) => Math.ceil((100 - progress) / speed)),
    featureCount,
    head
);
